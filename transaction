一. 事 务 概 念 : (Transaction) 


    把多条sql操作,作为一个操作单元,要么都成功要么都失败.

    是由一系列对系统中数据进行访问与更新的操作 所组成的一个程序执行逻辑单元.

    只有 Innodb 表引擎 支持事务.

    
    1. 事 务 的 ACID 特 性 :

        (1) Atomicity(原子性)    多条归为一个整体操作,整体开始,整体结束.


        (2) Consistency(一致性)  数据库执行事务操作前与操作后,数据是一致的. 


        (3) Isolatioin(隔离性)   在并发环境中,并发的事务是互相隔离的.

                不同的事务并发操作相同的数据时,每个事务都有各自完整的数据空间. 

                一个事务执行时,将被操作的对象锁住,执行完后解锁,另一个事务再来.

                有4个隔离级别,隔离性和难度逐渐递增.


        (4) Duration(持久性)     事务完成后对数据库的影响是永久的.(修改磁盘文件)



二. 事 务 操 作 :


  1. 事 务 的 操 作 语 法 :

    <1> begin/start transaction

    
    <2> commit;    使得当前修改确认.


    <3> rollback;  使得当前修改被放弃.

  
  2. 事 务 操 作 步 骤 : 

    <1> 开 启 事 务 : begin;


    <2> 执行 sql 语句 : 此时只临时修改,并没有对数据库的实际内容进行修改.


    <3> 提交 或 放弃 : 

            如果逻辑正确,执行 commit; 关闭本次事务,并修改表的实际数据.

            如果逻辑错误,执行 rollback; 关闭本次事务,并放弃本次修改. 



三. 事 务 的 并发 隔离级别 及 操作 :


  1. 事 务 的 并 发 问 题 :

    <1> 脏读 : 一个事务读到了 其他事务更新但没提交的数据,读到的就是脏数据.
    
               事务A 读取了 事务B更新之后的数据,然后 事务B回滚操作

               那么 事务A 读大的数据就是 脏数据.

               MySQL设置 读未提交 就会出现此情况.

        问 题 : 在B还没有回滚或提交之间,A用该数据进行了操作,那么结果就是有问题的


    <2> 不可重复 读开启事务时 数据 : 
    
                   事务A 的同一条查询命令,返回不同的结果,事务A多次读取同一数据
                   事务B 在事务A 多次读取的过程中,对数据做了更新并提交
                   事务A 在 读已提交 的隔离等级下,多次读取数据,结果不一样.

                   造成 多次读 结果都不一样,就叫 <不可重复读取当前的数据>.


    <3> 幻 读 : 事务A 在做统计,事务B 在做添加修改,事务A 得到的结果是不一样的.

           只会出现在 事务B 做了修改并结束事务,事务A 在事务中 <只有> 进行了
           范围性修改时(指定id不行),不必提交,查询数据时,会看到 事务B做的修改.


  2. 事 务 的 隔 离 级 别 : (不可重复读 为 不可重复读开启事务时的数据)
                                                  脏读  不可重复读    幻读   

<1> 读未提交(READ_UNCOMMITTED) read_uncommitteda  允许    允许      允许

<2> 读已提交(READ_COMMITTED)   read_committed     禁止    允许      允许

<3> 可重复读(REPEATABLE_READ)  repeatable_read    禁止    禁止      可能会

<4> 顺序读(SERIALIZABLE)       serializable       禁止    禁止      禁止

    越往下 隔离级别越高(安全性越高),但并发性越差.

    <3> 可 重 复 读 的 并 发 : 多个事务可以同时开启,但是只要在一个事务 提交 
    
    或 回滚 之后,另一个事务 才可以 对数据进行操作.

    <4> 顺序读是最严格的事务隔离级别,它要求所有的事务排队完成执行,即事务只能

        一个接一个地处理,不能并发.
        
        (可同时开启事务,但要等一个 事务结束时 另一个事务才可进行具体操作)

{
! ! ! 总 结 :

    读未提交(RU) : 一个事务中 能读 其他事务 没有提交的.
    读已提交(RC) : 一个事务中 不能读 其他事务 未提交的,但可以随时读已提交的.
    可重复读(RR) : 一个事物中 不能读 其他事务 未提交 或 已提交的数据.
               在其他事务结束时,该事务才可做修改操作,
               但在该事务中 始终 无法查到 其他事务修改后的最新数据.
    顺序读(S) : 不能处理并发,一个事务结束,另一个事务才可操作.
    
}
  
  3. 事 务 隔 离 级 别 操 作 :

    session 当前会话 (当前连接服务器的会话)    
    
    global  全局会话 (所有连接服务器的会话,对服务器进行修改)

    <1> 查看当前会话中 系统定义的 事务的隔离级别 :
            
            select @@tx_isolation;

    <2> 设置当前会话中的事务的隔离级别 :

            set session transaction isolation level read uncommitted;

    <3> 设置系统所有会话的事务的隔离级别 :

            set session transaction isolation level read uncommitted;

        注 意 : 设置隔离级别时,不加下划线.


四. 不 同 的 隔 离 级 别 锁 的 情 况 :

    间隙锁 : 范围性的锁.

    1. 读未提交(RU) : 有行级锁,没有间隙锁.与RC的区别是能够查询到未提交的数据.

    2. 读已提交(RC) : 有行级锁,没有间隙锁,读不到没有提交的数据.

    3. 可重复读(RR) : 有行级锁,没有间隙锁,每次读取的数据是一样的,有幻读.

    4. 序列化(S) : 有行几锁,也有间隙锁,读表的时候,就已经上锁了.
